// GENERATED BY CURSOR (strict) â€” changed Phase 1 on 2025-09-30. ASSUMPTION: Pure mock service.
// Phase 3: Extended with Card, NetBanking, and Bank Transfer payment methods
// TODO_BACKEND: Replace implementations with real API calls; keep method signatures intact.

import 'dart:async';
import 'dart:math';

import '../models/payment_result.dart';
import '../models/card_details.dart';
import '../models/netbanking_details.dart';
import '../models/transfer_details.dart';

class MockPaymentService {
  static Future<PaymentResult> processUpi({
    required String upiId, 
    required String plan, 
    String? courseId, 
    String? courseTitle, 
    double? amount
  }) async {
    await Future.delayed(const Duration(milliseconds: 900));
    final rng = Random();
    final ok = rng.nextBool();
    if (ok) {
      final label = courseTitle != null ? 'course "$courseTitle"' : plan;
      final orderId = _generateOrderId();
      return PaymentResult.success(
        message: 'Payment successful for $label via $upiId',
        orderId: orderId,
        paymentId: _generatePaymentId(),
      );
    }
    return PaymentResult.failure(
      message: 'Payment declined. Please try again.',
      errorCode: 'PAYMENT_DECLINED',
    );
  }

  /// Mock card payment processing
  static Future<PaymentResult> processCardPayment({
    required CardDetails cardDetails,
    required double amount,
    required String currency,
    String? orderId,
    String? courseId,
    String? courseTitle,
  }) async {
    // Simulate network delay
    await Future.delayed(const Duration(milliseconds: 1200));

    // Basic validation (already done in UI, but double-checking)
    if (!cardDetails.isValidLuhn) {
      return PaymentResult.failure(
        message: 'Invalid card number. Please check and try again.',
        errorCode: 'INVALID_CARD',
        orderId: orderId,
      );
    }

    // Mock payment processing with random success/failure
    final rng = Random();
    final successRate = 0.85; // 85% success rate for mock
    final isSuccess = rng.nextDouble() < successRate;

    if (isSuccess) {
      final label = courseTitle != null ? 'course "$courseTitle"' : 'subscription';
      final finalOrderId = orderId ?? _generateOrderId();
      return PaymentResult.success(
        message: 'Payment of ${currency.toUpperCase()} ${amount.toStringAsFixed(2)} successful for $label',
        orderId: finalOrderId,
        paymentId: _generatePaymentId(),
        signature: _generateSignature(),
      );
    } else {
      // Random failure reasons
      final failureReasons = [
        'Insufficient funds in account',
        'Card expired or blocked',
        'Transaction limit exceeded',
        'Bank declined the transaction',
        'Network timeout. Please try again',
      ];
      final randomReason = failureReasons[rng.nextInt(failureReasons.length)];
      
      return PaymentResult.failure(
        message: randomReason,
        errorCode: 'PAYMENT_FAILED',
        orderId: orderId,
      );
    }
  }

  /// Mock netbanking payment processing
  static Future<PaymentResult> processNetbankingPayment({
    required NetbankingDetails bankDetails,
    required double amount,
    required String currency,
    String? orderId,
    String? courseId,
    String? courseTitle,
  }) async {
    // Simulate network delay
    await Future.delayed(const Duration(milliseconds: 1500));

    final rng = Random();
    final successRate = 0.90; // 90% success rate for netbanking mock
    final isSuccess = rng.nextDouble() < successRate;

    if (isSuccess) {
      final label = courseTitle != null ? 'course "$courseTitle"' : 'subscription';
      final finalOrderId = orderId ?? _generateOrderId();
      return PaymentResult.success(
        message: 'Payment of ${currency.toUpperCase()} ${amount.toStringAsFixed(2)} successful for $label via ${bankDetails.bankName}',
        orderId: finalOrderId,
        paymentId: _generatePaymentId(),
        signature: _generateSignature(),
      );
    } else {
      // Random failure reasons
      final failureReasons = [
        'Bank server temporarily unavailable',
        'Invalid bank credentials',
        'Transaction timeout',
        'Daily limit exceeded',
        'Bank maintenance in progress',
      ];
      final randomReason = failureReasons[rng.nextInt(failureReasons.length)];
      
      return PaymentResult.failure(
        message: randomReason,
        errorCode: 'NETBANKING_FAILED',
        orderId: orderId,
      );
    }
  }

  /// Mock bank transfer payment processing
  static Future<PaymentResult> processTransferPayment({
    required TransferDetails transferDetails,
    required double amount,
    required String currency,
    String? orderId,
    String? courseId,
    String? courseTitle,
  }) async {
    // Simulate network delay (transfers take longer)
    await Future.delayed(const Duration(milliseconds: 2000));

    // Validate IFSC and account number
    if (!transferDetails.isValidIfsc) {
      return PaymentResult.failure(
        message: 'Invalid IFSC code. Please check and try again.',
        errorCode: 'INVALID_IFSC',
        orderId: orderId,
      );
    }

    if (!transferDetails.isValidAccountNumber) {
      return PaymentResult.failure(
        message: 'Invalid account number. Please check and try again.',
        errorCode: 'INVALID_ACCOUNT',
        orderId: orderId,
      );
    }

    final rng = Random();
    final successRate = 0.80; // 80% success rate for transfer mock
    final isSuccess = rng.nextDouble() < successRate;

    if (isSuccess) {
      final label = courseTitle != null ? 'course "$courseTitle"' : 'subscription';
      final finalOrderId = orderId ?? _generateOrderId();
      final bankName = transferDetails.bankCode; // Could be enhanced with full bank name lookup
      
      return PaymentResult.success(
        message: 'Transfer of ${currency.toUpperCase()} ${amount.toStringAsFixed(2)} initiated successfully for $label to $bankName',
        orderId: finalOrderId,
        paymentId: _generatePaymentId(),
        signature: _generateSignature(),
      );
    } else {
      // Random failure reasons
      final failureReasons = [
        'Account number not found',
        'IFSC code mismatch',
        'Beneficiary account blocked',
        'Transfer limit exceeded',
        'Bank network unavailable',
      ];
      final randomReason = failureReasons[rng.nextInt(failureReasons.length)];
      
      return PaymentResult.failure(
        message: randomReason,
        errorCode: 'TRANSFER_FAILED',
        orderId: orderId,
      );
    }
  }

  /// Mock order creation (backend endpoint simulation)
  static Future<String> createOrder({
    required double amount,
    required String currency,
    String? courseId,
    String? courseTitle,
    Map<String, dynamic>? metadata,
  }) async {
    // Simulate backend API call delay
    await Future.delayed(const Duration(milliseconds: 500));
    
    // In real implementation, this would call backend to create order with Razorpay
    return _generateOrderId();
  }

  /// Mock payment verification (backend endpoint simulation)
  static Future<PaymentResult> verifyPayment({
    required String paymentId,
    required String orderId,
    String? signature,
  }) async {
    // Simulate backend verification delay
    await Future.delayed(const Duration(milliseconds: 800));
    
    // In real implementation, this would verify payment signature with Razorpay
    final rng = Random();
    final isVerified = rng.nextDouble() < 0.95; // 95% verification success rate
    
    if (isVerified) {
      return PaymentResult.success(
        message: 'Payment verified successfully',
        orderId: orderId,
        paymentId: paymentId,
        signature: signature,
      );
    } else {
      return PaymentResult.failure(
        message: 'Payment verification failed',
        errorCode: 'VERIFICATION_FAILED',
        orderId: orderId,
      );
    }
  }

  // Helper methods for generating mock IDs
  static String _generateOrderId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final rng = Random();
    final random = rng.nextInt(9999).toString().padLeft(4, '0');
    return 'order_$timestamp$random';
  }

  static String _generatePaymentId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final rng = Random();
    final random = rng.nextInt(9999).toString().padLeft(4, '0');
    return 'pay_$timestamp$random';
  }

  static String _generateSignature() {
    final rng = Random();
    const chars = 'abcdef0123456789';
    return List.generate(32, (index) => chars[rng.nextInt(chars.length)]).join();
  }
}


